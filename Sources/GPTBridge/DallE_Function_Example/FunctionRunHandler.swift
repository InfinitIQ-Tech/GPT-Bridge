//
//  FunctionRunHandler.swift
//  SlackMojiChef
//
//  Created by Kenneth Dubroff on 12/16/23.
//

import SwiftUI

protocol FunctionRunHandlable: RunHandler {
    var requiredAction: RequiredAction? { get }

    func parse() throws -> DallE3FunctionArguments
}

extension FunctionRunHandlable {
    private var noActionRetrievedError: NSError {
        NSError(domain: "noActionRetrievedError", code: 0, userInfo: nil)
    }

    func parse() throws  -> DallE3FunctionArguments {
       guard let action = requiredAction,
             action.submitToolOutputs.toolCalls.count > 0
       else {
           throw noActionRetrievedError
       }
       return action.submitToolOutputs.toolCalls[0].function.arguments // TODO: Generic arguments
    }
}
/// Assumes an assistant with a function that returns an image prompt
class FunctionRunHandler: FunctionRunHandlable {
    private enum Error: Swift.Error {
        /// No required action in the run response
        case noRequiredActionRetrieved
    }


    var requiredAction: RequiredAction?
    // MARK: RunHandler implementation
    var runThreadResponse: RunThreadResponse

    /// The image name the assistant generated
    var imageName: String?
    /// The prompt the assistant generated in order to generate the image
    var prompt: String?
    /// The URL from Dall*E 3
    /// - NOTE: Will be nil until `handle()` completes
    var imageUrl: URL?

    init(runThreadResponse: RunThreadResponse) {
        self.runThreadResponse = runThreadResponse
        self.requiredAction = runThreadResponse.requiredAction
    }
    
    /// Generate an image
    /// 1. Parse the function arguments retrieved from `runThreadResponse`
    ///     - imageName: String
    ///       - available immediately, generated by assistant
    ///     - prompt: String
    ///       - available immediately, generated by assistant
    /// 2. Generate an image using the prompt
    /// 3. Set self.imageUrl
    /// - Throws: `noRequiredActionRetrieved` on nil `requiredAction` or requiredAction's `toolCalls` array being empty
    func handle() async throws {
        let arguments = try parse()
        let prompt = arguments.prompt
        self.prompt = prompt
        self.imageName = arguments.photoName
        let dallEHandler = DallEHandler(prompt: prompt)
        self.imageUrl = try await dallEHandler.generateImage()
    }
}

/// Generate images given a prompt
class DallEHandler: EncodableRequest {
    enum Error: Swift.Error {
        /// HTTPResponse error
        case badResponse
        /// no url existed in the payload from Dall*E
        case noUrl
    }
    /// The prompt to send to Dall*E 3
    let prompt: String
    private let model = "dall-e-3"
    private let size = "1024x1024"
    private let n = 1
    private var quality: String = "standard"

    init(prompt: String) {
        self.prompt = prompt
    }
    /// Generate an image with Dall*E 3
    /// - Returns: the URL of the generated image (expires in 1 hour)
    func generateImage() async throws -> URL {
        self.quality = "hd"
        var request = URLRequest(url: URL(string: "https://api.openai.com/v1/images/generations")!)
        request.httpMethod = HttpMethod.POST.rawValue
        request.httpBody = try encodeInstance()
        request.allHTTPHeaderFields = jsonPayloadHeaders

        let (data, urlResponse) = try await URLSession.shared.data(for: request)
        guard let httpResponse = urlResponse as? HTTPURLResponse,
              httpResponse.statusCode >= 200 && httpResponse.statusCode < 300
        else {
            throw Error.badResponse
        }

        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase

        let dataArray = try jsonDecoder.decode(DallEResponse.self, from: data).data
        guard dataArray.count > 0 else { throw Error.noUrl }
        return dataArray[0].url
    }
}

/// Dall*E 3 payload
struct DallEResponse: DecodableResponse {
    let data: [DallEURLParameterResponse]
}

struct DallEURLParameterResponse: DecodableResponse {
    let url: URL
}
